#!/bin/sh

set -eu

# Initialize environment variables
if [ -f /config/app.env ]; then
    # Robust .env loader (supports spaces after '='; ignores comments/blank lines).
    while IFS= read -r line || [ -n "$line" ]; do
        # Strip CRLF
        line="${line%\r}"
        case "$line" in
            ''|\#*) continue ;;
        esac
        # Support optional leading 'export '
        case "$line" in
            export\ *) line="${line#export }" ;;
        esac
        case "$line" in
            *=*)
                key="${line%%=*}"
                val="${line#*=}"
                key="$(printf '%s' "$key" | tr -d ' \t')"
                # Skip invalid keys
                case "$key" in
                    ''|*[!A-Za-z0-9_]* ) continue ;;
                esac
                export "$key=$val"
                ;;
        esac
    done < /config/app.env
fi

python3 /app/tools/adblock_compile.py \
    --db /var/lib/squid-flask-proxy/adblock.db \
    --lists-dir /var/lib/squid-flask-proxy/adblock/lists \
    --out-dir /var/lib/squid-flask-proxy/adblock/compiled \
    || true

# Ensure squid.conf is based on our template (needed for caching + ssl-bump).
# If the file already looks like our managed config, keep it.
PERSISTED_SQUID_CONF_PATH="${PERSISTED_SQUID_CONF_PATH:-/var/lib/squid-flask-proxy/squid.conf}"
if [ -f "$PERSISTED_SQUID_CONF_PATH" ]; then
    mkdir -p /etc/squid
    cp "$PERSISTED_SQUID_CONF_PATH" /etc/squid/squid.conf

    # Squid 6+ deprecates "pipeline_prefetch on" in favor of numeric values.
    # Migrate the persisted config in-memory for this container run.
    if grep -qiE "^\s*pipeline_prefetch\s+on\b" /etc/squid/squid.conf 2>/dev/null; then
        sed -i -E "s/^([[:space:]]*pipeline_prefetch[[:space:]]+)on\b/\11/I" /etc/squid/squid.conf
    fi
    if grep -qiE "^\s*pipeline_prefetch\s+off\b" /etc/squid/squid.conf 2>/dev/null; then
        sed -i -E "s/^([[:space:]]*pipeline_prefetch[[:space:]]+)off\b/\10/I" /etc/squid/squid.conf
    fi
fi

TEMPLATE=""
if [ -f /etc/squid/squid.conf.template ]; then
    TEMPLATE="/etc/squid/squid.conf.template"
elif [ -f /squid/squid.conf.template ]; then
    TEMPLATE="/squid/squid.conf.template"
fi

if [ -n "$TEMPLATE" ] && [ ! -f "$PERSISTED_SQUID_CONF_PATH" ]; then
    if [ ! -f /etc/squid/squid.conf ] || ! grep -q "ssl_bump" /etc/squid/squid.conf 2>/dev/null; then
        cp "$TEMPLATE" /etc/squid/squid.conf
    fi
fi

# Squid 6/7 expects logfile paths to be prefixed with a module name.
# Normalize common log directives to use stdio: to avoid warnings and improve rotation.
if [ -f /etc/squid/squid.conf ]; then
    # access_log may include a logformat and ACLs after the path; preserve the tail.
    sed -i -E 's#^([[:space:]]*access_log[[:space:]]+)(stdio:)?/var/log/squid/access\.log([[:space:]]+)#\1stdio:/var/log/squid/access.log\3#' /etc/squid/squid.conf || true
    sed -i -E 's#^([[:space:]]*cache_log[[:space:]]+)(stdio:)?/var/log/squid/cache\.log([[:space:]]*|$)#\1stdio:/var/log/squid/cache.log\3#' /etc/squid/squid.conf || true
    sed -i -E 's#^([[:space:]]*cache_store_log[[:space:]]+)(stdio:)?/var/log/squid/store\.log([[:space:]]*|$)#\1stdio:/var/log/squid/store.log\3#' /etc/squid/squid.conf || true
fi

# Keep log noise down: exclude local cachemgr polling from access.log.
# We apply this even if squid.conf already exists (e.g., user edited via UI),
# but only inject once.
if [ -f /etc/squid/squid.conf ] && ! grep -q "acl squid_internal_mgr" /etc/squid/squid.conf 2>/dev/null; then
    if grep -q "^access_log \(stdio:\)\?/var/log/squid/access\\.log liveui" /etc/squid/squid.conf 2>/dev/null; then
        sed -i '/^access_log \(stdio:\)\?\/var\/log\/squid\/access\.log liveui/i\
\
# Filter noisy internal cache manager polling (e.g. /squid-internal-mgr/info, /squid-internal-mgr/5min)\
# from localhost. These are generated by the local admin/UI and are not end-user proxy traffic.\
acl src_localhost src 127.0.0.1\/32 ::1\
acl squid_internal_mgr urlpath_regex -i ^\/squid-internal-mgr\/\
access_log none src_localhost squid_internal_mgr\
' /etc/squid/squid.conf
    else
        cat >> /etc/squid/squid.conf <<'EOF'

# Filter noisy internal cache manager polling (e.g. /squid-internal-mgr/info, /squid-internal-mgr/5min)
# from localhost. These are generated by the local admin/UI and are not end-user proxy traffic.
acl src_localhost src 127.0.0.1/32 ::1
acl squid_internal_mgr urlpath_regex -i ^/squid-internal-mgr/
access_log none src_localhost squid_internal_mgr
EOF
    fi
fi

# SECURITY: Ensure the live UI logformat does not log credentials (Authorization/Cookie).
# Users may persist/edit squid.conf via the UI; enforce a safe default on startup.
SAFE_LIVEUI_FMT='logformat liveui %ts\t%tr\t%>a\t%rm\t%ru\t%Ss/%>Hs\t%st\t"%{Cache-Control}>h"\t"%{Pragma}>h"\t"%{Cache-Control}<h"\t"%{Pragma}<h"\t"%{Expires}<h"\t"%{Vary}<h"\t"%{Set-Cookie}<h"'
if [ -f /etc/squid/squid.conf ] && grep -q "^logformat liveui" /etc/squid/squid.conf 2>/dev/null; then
    if grep -q "%{Authorization}>h\|%{Cookie}>h" /etc/squid/squid.conf 2>/dev/null; then
        # Replace any existing liveui logformat line with the safe variant.
        sed -i -E "s#^logformat[[:space:]]+liveui[[:space:]].*#${SAFE_LIVEUI_FMT}#" /etc/squid/squid.conf
    fi
fi

# Stability + privacy: never cache requests that carry Authorization/Cookie.
# This reduces Vary-related cache loops and prevents caching of authenticated content.
if [ -f /etc/squid/squid.conf ] && ! grep -q "^acl has_auth req_header Authorization" /etc/squid/squid.conf 2>/dev/null; then
    cat >> /etc/squid/squid.conf <<'EOF'

# Never cache authenticated or cookie-bearing traffic.
acl has_auth req_header Authorization .
acl has_cookie req_header Cookie .
cache deny has_auth
cache deny has_cookie
EOF
fi

# Stability: avoid problematic half-closed client connections.
# We have observed Squid aborting with an internal assertion (SIGABRT) under some client
# behaviors when half-closed connections are enabled. Disabling this is generally safer.
if [ -f /etc/squid/squid.conf ]; then
    if grep -qiE "^\s*half_closed_clients\s+" /etc/squid/squid.conf 2>/dev/null; then
        sed -i -E "s#^([[:space:]]*half_closed_clients[[:space:]]+).*$#\1off#I" /etc/squid/squid.conf || true
    else
        cat >> /etc/squid/squid.conf <<'EOF'

# Stability: disable half-closed clients (safer with misbehaving clients).
half_closed_clients off
EOF
    fi
fi

# Ensure we keep a bounded number of rotated log files.
# Even if the user persists/edits squid.conf via the UI, add a safe default if missing.
if [ -f /etc/squid/squid.conf ] && ! grep -q "^\s*logfile_rotate\b" /etc/squid/squid.conf 2>/dev/null; then
    echo "" >> /etc/squid/squid.conf
    echo "# Default log retention for squid -k rotate (daily via supervisor)." >> /etc/squid/squid.conf
    echo "logfile_rotate 10" >> /etc/squid/squid.conf
fi

# Generate Squid include snippets for ICAP scaling.
# We derive the worker count from squid.conf so UI edits like "workers 4" validate.
mkdir -p /etc/squid/conf.d

# SSL filtering include is driven by the admin UI (SQLite settings).
# Always generate a safe include so squid.conf can include it.
python3 /app/tools/sslfilter_apply.py || true

# Web filtering include is driven by the admin UI (SQLite settings).
# Always generate a safe include so squid.conf.template's include succeeds.
python3 /app/tools/webfilter_apply.py || true

# Ensure the SSL filtering include is present in squid.conf even if a user edited/persisted it.
# It should appear after 'ssl_bump peek step1' and before any 'ssl_bump bump' rule.
if [ -f /etc/squid/squid.conf ] && ! grep -q "/etc/squid/conf.d/10-sslfilter.conf" /etc/squid/squid.conf 2>/dev/null; then
    TMP="/tmp/squid.conf.$$"
    awk '
        BEGIN{inserted=0}
        /^ssl_bump peek step1$/ && !inserted {
            print;
            print "# SSL filtering (no-bump CIDRs). Safe if empty.";
            print "include /etc/squid/conf.d/10-sslfilter.conf";
            inserted=1;
            next
        }
        /^ssl_bump bump/ && !inserted {
            print "# SSL filtering (no-bump CIDRs). Safe if empty.";
            print "include /etc/squid/conf.d/10-sslfilter.conf";
            inserted=1;
            print;
            next
        }
        {print}
        END{
            if(!inserted){
                print "";
                print "# SSL filtering (no-bump CIDRs). Safe if empty.";
                print "include /etc/squid/conf.d/10-sslfilter.conf";
            }
        }
    ' /etc/squid/squid.conf > "$TMP" && mv "$TMP" /etc/squid/squid.conf || rm -f "$TMP"
fi

# Steam downloads/auth endpoints are frequently intolerant of TLS interception.
# If the client shows "No Connection" unless bypassing *.steamserver.net, splice those
# destinations (no MITM) while keeping bump enabled for other traffic.
if [ -f /etc/squid/squid.conf ]; then
    # NOTE: Use a single idempotent rewrite.
    # - Removes any previously injected/corrupted steam lines.
    # - Inserts the steam ACL in a safe location (after 'acl step1...' or before ssl_bump rules).
    # - Inserts splice rule before any bump rule (or right after sslfilter include when present).
    TMP="/tmp/squid.conf.$$"
    awk '
        BEGIN { added_acl=0; inserted_splice=0 }

        # Drop any existing (or corrupted) steam ACL/splice lines to avoid duplicates.
        /^[[:space:]]*(acl|cl)[[:space:]]+steam_sites[[:space:]]+ssl::server_name[[:space:]]+\.steamserver\.net[[:space:]]*$/ { next }
        /^[[:space:]]*ssl_bump[[:space:]]+splice[[:space:]]+steam_sites[[:space:]]*$/ { next }

        {
            # Prefer placing the ACL alongside other ssl-bump ACLs.
            if ($0 ~ /^acl step1 at_step SslBump1[[:space:]]*$/ && !added_acl) {
                print;
                print "acl steam_sites ssl::server_name .steamserver.net";
                added_acl=1;
                next;
            }

            # If we have not placed the ACL yet, place it just before the first ssl_bump rule.
            if ($0 ~ /^ssl_bump[[:space:]]+/ && !added_acl) {
                print "acl steam_sites ssl::server_name .steamserver.net";
                added_acl=1;
            }

            # Prefer placing splice rule right after sslfilter include.
            if ($0 ~ /^include[[:space:]]+\/etc\/squid\/conf\.d\/10-sslfilter\.conf[[:space:]]*$/ && !inserted_splice) {
                print;
                print "";
                print "# Steam downloads/auth endpoints are frequently intolerant of TLS interception.";
                print "# Splice steamserver.net (no MITM) to improve Steam client reliability.";
                print "ssl_bump splice steam_sites";
                inserted_splice=1;
                next;
            }

            # Otherwise ensure splice happens before the first bump rule.
            if ($0 ~ /^ssl_bump[[:space:]]+bump/ && !inserted_splice) {
                print "";
                print "# Steam downloads/auth endpoints are frequently intolerant of TLS interception.";
                print "# Splice steamserver.net (no MITM) to improve Steam client reliability.";
                print "ssl_bump splice steam_sites";
                inserted_splice=1;
                print;
                next;
            }

            print;
        }

        END {
            # If there are no ssl_bump rules at all, append at the end (best-effort).
            if (!added_acl) {
                print "";
                print "acl steam_sites ssl::server_name .steamserver.net";
            }
            if (!inserted_splice) {
                print "";
                print "# Steam downloads/auth endpoints are frequently intolerant of TLS interception.";
                print "# Splice steamserver.net (no MITM) to improve Steam client reliability.";
                print "ssl_bump splice steam_sites";
            }
        }
    ' /etc/squid/squid.conf > "$TMP" && mv "$TMP" /etc/squid/squid.conf || rm -f "$TMP"
fi

WORKERS=""
if [ -f /etc/squid/squid.conf ]; then
    # Extract the first "workers N" directive.
    WORKERS=$(awk 'tolower($1)=="workers" && $2 ~ /^[0-9]+$/ {print $2; exit}' /etc/squid/squid.conf 2>/dev/null || true)
fi

if [ -z "$WORKERS" ]; then
    WORKERS_RAW="${SQUID_WORKERS:-2}"
    case "$WORKERS_RAW" in
        ''|*[!0-9]*) WORKERS=2 ;;
        *) WORKERS="$WORKERS_RAW" ;;
    esac
fi

if [ "$WORKERS" -lt 1 ]; then
    WORKERS=1
fi

# Ensure supervisord sees a valid value even if compose didn't set it.
export SQUID_WORKERS="$WORKERS"

mkdir -p /etc/supervisor.d
rm -f /etc/supervisor.d/icap.conf || true

# Run c-icap for adblock REQMOD (no ClamAV dependency) and AV (ClamAV).
# We start an adblock-only c-icap instance immediately so Squid's ICAP OPTIONS checks succeed
# quickly. A second c-icap instance (AV) can wait for the clamd socket without impacting adblock.
CICAP_PORT_RAW="${CICAP_PORT:-14000}"
case "$CICAP_PORT_RAW" in
    ''|*[!0-9]*) CICAP_PORT=14000 ;;
    *) CICAP_PORT="$CICAP_PORT_RAW" ;;
esac

CICAP_AV_PORT_RAW="${CICAP_AV_PORT:-14001}"
case "$CICAP_AV_PORT_RAW" in
    ''|*[!0-9]*) CICAP_AV_PORT=14001 ;;
    *) CICAP_AV_PORT="$CICAP_AV_PORT_RAW" ;;
esac

mkdir -p /var/run/c-icap

# Generate per-instance c-icap configs from the base image config.
# - adblock instance: no clamd_mod / virus_scan
# - av instance: full config (waits for clamd socket before starting)
if [ -f /etc/c-icap/c-icap.conf ]; then
    cp /etc/c-icap/c-icap.conf /etc/c-icap/c-icap-av.conf
    cp /etc/c-icap/c-icap.conf /etc/c-icap/c-icap-adblock.conf

    # Ensure distinct pidfiles for multiple instances.
    if grep -qiE "^[[:space:]]*PidFile[[:space:]]+" /etc/c-icap/c-icap-av.conf 2>/dev/null; then
        sed -i -E "s#^[[:space:]]*PidFile[[:space:]]+.*#PidFile /var/run/c-icap/c-icap-av.pid#I" /etc/c-icap/c-icap-av.conf
    else
        echo "PidFile /var/run/c-icap/c-icap-av.pid" >> /etc/c-icap/c-icap-av.conf
    fi

    if grep -qiE "^[[:space:]]*PidFile[[:space:]]+" /etc/c-icap/c-icap-adblock.conf 2>/dev/null; then
        sed -i -E "s#^[[:space:]]*PidFile[[:space:]]+.*#PidFile /var/run/c-icap/c-icap-adblock.pid#I" /etc/c-icap/c-icap-adblock.conf
    else
        echo "PidFile /var/run/c-icap/c-icap-adblock.pid" >> /etc/c-icap/c-icap-adblock.conf
    fi

    # Avoid both instances writing to the same access log.
    # Keep the default access log path for adblock (used by the UI/SQLite ingestion).
    if grep -qiE "^[[:space:]]*AccessLog[[:space:]]+/var/log/cicap-access\.log([[:space:]]|$)" /etc/c-icap/c-icap-av.conf 2>/dev/null; then
        sed -i -E "s#^[[:space:]]*AccessLog[[:space:]]+/var/log/cicap-access\.log([[:space:]]|$)#AccessLog /var/log/cicap-access-av.log\1#I" /etc/c-icap/c-icap-av.conf
    fi

    # Set ports
    if grep -qiE "^[[:space:]]*Port[[:space:]]+" /etc/c-icap/c-icap-av.conf 2>/dev/null; then
        sed -i -E "s#^[[:space:]]*Port[[:space:]]+.*#Port 127.0.0.1:${CICAP_AV_PORT}#I" /etc/c-icap/c-icap-av.conf
    else
        echo "Port 127.0.0.1:${CICAP_AV_PORT}" >> /etc/c-icap/c-icap-av.conf
    fi

    if grep -qiE "^[[:space:]]*Port[[:space:]]+" /etc/c-icap/c-icap-adblock.conf 2>/dev/null; then
        sed -i -E "s#^[[:space:]]*Port[[:space:]]+.*#Port 127.0.0.1:${CICAP_PORT}#I" /etc/c-icap/c-icap-adblock.conf
    else
        echo "Port 127.0.0.1:${CICAP_PORT}" >> /etc/c-icap/c-icap-adblock.conf
    fi

    # Strip AV-related bits from the adblock-only instance.
    sed -i -E '\#^[[:space:]]*Include[[:space:]]+/etc/clamd_mod\.conf([[:space:]]|$)#d' /etc/c-icap/c-icap-adblock.conf
    sed -i -E '/^[[:space:]]*Service[[:space:]]+virus_scan([[:space:]]|$)/d' /etc/c-icap/c-icap-adblock.conf
    sed -i -E '/^[[:space:]]*ServiceAlias[[:space:]]+avrespmod([[:space:]]|$)/d' /etc/c-icap/c-icap-adblock.conf
    sed -i -E '\#^[[:space:]]*Include[[:space:]]+/etc/virus_scan\.conf([[:space:]]|$)#d' /etc/c-icap/c-icap-adblock.conf
fi

cat > /etc/supervisor.d/cicap_adblock.conf <<'EOF'
[program:cicap_adblock]
command=/usr/bin/c-icap -N -d 1 -f /etc/c-icap/c-icap-adblock.conf
autostart=true
autorestart=true
priority=10
stderr_logfile=/dev/stderr
stdout_logfile=/dev/stdout
stderr_logfile_maxbytes=0
stdout_logfile_maxbytes=0
EOF

cat > /etc/supervisor.d/cicap_av.conf <<'EOF'
[program:cicap_av]
# Wait for clamd's unix socket so clamd_mod can register the engine before virus_scan starts.
command=/bin/sh -c 'SOCK=/var/lib/squid-flask-proxy/clamav/clamd.sock; i=0; while [ $i -lt 120 ]; do [ -S "$SOCK" ] && break; i=$((i+1)); sleep 1; done; exec /usr/bin/c-icap -N -d 1 -f /etc/c-icap/c-icap-av.conf'
autostart=true
autorestart=true
priority=11
stderr_logfile=/dev/stderr
stdout_logfile=/dev/stdout
stderr_logfile_maxbytes=0
stdout_logfile_maxbytes=0
EOF

{
    # One ICAP service per function.
    # Duplicating multiple `icap_service` entries pointing at the same URI (same local c-icap instance)
    # triggers Squid warnings about duplicate URIs and provides no scaling benefit.
    echo "icap_service adblock_req reqmod_precache icap://127.0.0.1:${CICAP_PORT}/adblockreq bypass=on"
    echo "icap_service av_resp respmod_precache icap://127.0.0.1:${CICAP_AV_PORT}/avrespmod bypass=on"
    echo "adaptation_service_set adblock_req_set adblock_req"
    echo "adaptation_service_set av_resp_set av_resp"

    # Reduce c-icap virus_scan warning noise:
    # - Some origins respond with deflate-compressed bodies when clients advertise support.
    # - virus_scan may fail to decompress deflate in some cases and logs warnings (PassOnError then lets it pass).
    # Asking origins for identity encoding avoids having compressed bodies at the ICAP boundary.
    # Scope to methods that we actually adapt (GET/HEAD) to minimize behavior changes.
    echo "acl icap_identity_methods method GET HEAD"
    echo "request_header_access Accept-Encoding deny icap_identity_methods"
    echo "request_header_add Accept-Encoding identity icap_identity_methods"
} > /etc/squid/conf.d/20-icap.conf

# Normalize known distro path differences without overwriting user config
if [ -f /etc/squid/squid.conf ] && grep -q "/usr/share/squid/errors/English" /etc/squid/squid.conf 2>/dev/null; then
    sed -i 's#/usr/share/squid/errors/English#/usr/share/squid/errors/en#g' /etc/squid/squid.conf
fi

# Initialize CA + SSL DB for ssl-bump
sh /scripts/init_ssl_db.sh

# Initialize cache dirs (safe to re-run)
mkdir -p /var/spool/squid /var/log/squid
mkdir -p /var/lib/squid-flask-proxy

# SECURITY: access.log may contain credentials from older configurations.
# Since /var/log/squid is not persisted as a volume, it's safe to purge on startup.
if [ "${SANITIZE_SQUID_ACCESS_LOGS_ON_START:-1}" = "1" ]; then
    rm -f /var/log/squid/access.log /var/log/squid/access.log.* 2>/dev/null || true
fi

# ClamAV bootstrap: first startup needs a signature DB download.
# Persist DB + socket under /var/lib/squid-flask-proxy so restarts are fast.
# Note: scanning enable/disable is controlled by Squid policy (web UI), not env vars.
# ClamAV on Alpine can be picky about config file line endings.
sed -i 's/\r$//' /etc/clamav/clamd.conf /etc/clamav/freshclam.conf 2>/dev/null || true

CLAMAV_ROOT="/var/lib/squid-flask-proxy/clamav"
CLAMAV_DB="${CLAMAV_ROOT}/db"
mkdir -p "${CLAMAV_DB}"
rm -f "${CLAMAV_ROOT}/clamd.sock" || true
if getent passwd clamav >/dev/null 2>&1; then
    chown -R clamav:clamav "${CLAMAV_ROOT}" || true
fi

if [ ! -f "${CLAMAV_DB}/main.cld" ] && [ ! -f "${CLAMAV_DB}/main.cvd" ]; then
    echo "[clamav] signature DB missing; running initial freshclam (blocking)..." >&2
    # Use our config so it writes into the persisted DatabaseDirectory.
    freshclam --foreground --stdout --config-file=/etc/clamav/freshclam.conf
    echo "[clamav] initial signature DB ready." >&2
fi

# Generate Dante (sockd) config used by supervisord.
# Default policy: no-auth SOCKS5, LAN-restricted, allow TCP + UDP.
if [ "${ENABLE_DANTE:-1}" = "1" ]; then
    # Ensure log file exists and is writable by the unprivileged user.
    mkdir -p /var/log
    touch /var/log/sockd.log || true
    if getent passwd sockd >/dev/null 2>&1; then
        chown sockd:sockd /var/log/sockd.log || true
    fi

    DANTE_INTERNAL="${DANTE_INTERNAL:-0.0.0.0}"
    DANTE_PORT="${DANTE_PORT:-1080}"
    DANTE_EXTERNAL="${DANTE_EXTERNAL:-eth0}"
    DANTE_ALLOW_FROM="${DANTE_ALLOW_FROM:-10.0.0.0/8 172.16.0.0/12 192.168.0.0/16}"
    DANTE_BLOCK_PRIVATE_DESTS="${DANTE_BLOCK_PRIVATE_DESTS:-1}"

    # Performance/robustness knobs.
    DANTE_DEBUG_RAW="${DANTE_DEBUG:-0}"
    case "$DANTE_DEBUG_RAW" in
        ''|*[!0-9]*) DANTE_DEBUG=0 ;;
        *) DANTE_DEBUG="$DANTE_DEBUG_RAW" ;;
    esac

    DANTE_TIMEOUT_NEGOTIATE_RAW="${DANTE_TIMEOUT_NEGOTIATE:-30}"
    case "$DANTE_TIMEOUT_NEGOTIATE_RAW" in
        ''|*[!0-9]*) DANTE_TIMEOUT_NEGOTIATE=30 ;;
        *) DANTE_TIMEOUT_NEGOTIATE="$DANTE_TIMEOUT_NEGOTIATE_RAW" ;;
    esac

    DANTE_TIMEOUT_CONNECT_RAW="${DANTE_TIMEOUT_CONNECT:-30}"
    case "$DANTE_TIMEOUT_CONNECT_RAW" in
        ''|*[!0-9]*) DANTE_TIMEOUT_CONNECT=30 ;;
        *) DANTE_TIMEOUT_CONNECT="$DANTE_TIMEOUT_CONNECT_RAW" ;;
    esac

    # 0 means "forever" in Dante; keep that default to avoid breaking long-lived sessions.
    DANTE_TIMEOUT_IO_TCP_RAW="${DANTE_TIMEOUT_IO_TCP:-0}"
    case "$DANTE_TIMEOUT_IO_TCP_RAW" in
        ''|*[!0-9]*) DANTE_TIMEOUT_IO_TCP=0 ;;
        *) DANTE_TIMEOUT_IO_TCP="$DANTE_TIMEOUT_IO_TCP_RAW" ;;
    esac

    DANTE_TIMEOUT_IO_UDP_RAW="${DANTE_TIMEOUT_IO_UDP:-0}"
    case "$DANTE_TIMEOUT_IO_UDP_RAW" in
        ''|*[!0-9]*) DANTE_TIMEOUT_IO_UDP=0 ;;
        *) DANTE_TIMEOUT_IO_UDP="$DANTE_TIMEOUT_IO_UDP_RAW" ;;
    esac

    DANTE_UDP_CONNECTDST="${DANTE_UDP_CONNECTDST:-yes}"
    case "$(printf '%s' "$DANTE_UDP_CONNECTDST" | tr 'A-Z' 'a-z')" in
        yes|no) : ;;
        *) DANTE_UDP_CONNECTDST=yes ;;
    esac

    # Logging keywords (connect/disconnect/error/data/ioop/tcpinfo).
    DANTE_LOG_RAW="${DANTE_LOG:-connect disconnect error}"
    # Keep only known keywords so bad env values don't break sockd startup.
    DANTE_LOG=""
    for tok in ${DANTE_LOG_RAW}; do
        case "$tok" in
            connect|disconnect|error|data|ioop|tcpinfo)
                DANTE_LOG="${DANTE_LOG} ${tok}"
                ;;
        esac
    done
    DANTE_LOG="$(printf '%s' "$DANTE_LOG" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')"
    if [ -z "$DANTE_LOG" ]; then
        DANTE_LOG="connect disconnect error"
    fi

    # Optional session limiting (applies per matching rule).
    DANTE_SESSION_MAX_RAW="${DANTE_SESSION_MAX:-}"
    case "$DANTE_SESSION_MAX_RAW" in
        ''|*[!0-9]*) DANTE_SESSION_MAX="" ;;
        0) DANTE_SESSION_MAX="" ;;
        *) DANTE_SESSION_MAX="$DANTE_SESSION_MAX_RAW" ;;
    esac

    # Optional session throttling: "<connections>/<seconds>" (e.g. "50/1").
    DANTE_SESSION_THROTTLE_RAW="${DANTE_SESSION_THROTTLE:-}"
    if printf '%s' "$DANTE_SESSION_THROTTLE_RAW" | grep -qE '^[0-9]+/[0-9]+$'; then
        DANTE_SESSION_THROTTLE="$DANTE_SESSION_THROTTLE_RAW"
    else
        DANTE_SESSION_THROTTLE=""
    fi

    {
        echo "logoutput: stderr /var/log/sockd.log"
        echo "internal: ${DANTE_INTERNAL} port = ${DANTE_PORT}"
        echo "external: ${DANTE_EXTERNAL}"
        echo "debug: ${DANTE_DEBUG}"
        echo "timeout.negotiate: ${DANTE_TIMEOUT_NEGOTIATE}"
        echo "timeout.connect: ${DANTE_TIMEOUT_CONNECT}"
        echo "timeout.io.tcp: ${DANTE_TIMEOUT_IO_TCP}"
        echo "timeout.io.udp: ${DANTE_TIMEOUT_IO_UDP}"
        echo "udp.connectdst: ${DANTE_UDP_CONNECTDST}"
        echo "socksmethod: none"
        echo "clientmethod: none"
        echo "user.privileged: sockd"
        echo "user.unprivileged: sockd"
        echo

        # Allow localhost for in-container diagnostics/healthchecks.
        echo "client pass {"
        echo "        from: 127.0.0.1/32 port 1-65535 to: 0.0.0.0/0"
        echo "        log: ${DANTE_LOG}"
        echo "}"
        echo

        # Client allow-list (who may connect to the SOCKS server).
        for cidr in ${DANTE_ALLOW_FROM}; do
            echo "client pass {"
            echo "        from: ${cidr} port 1-65535 to: 0.0.0.0/0"
            echo "        log: ${DANTE_LOG}"
            echo "}"
            echo
        done
        echo "client block {"
        echo "        from: 0.0.0.0/0 to: 0.0.0.0/0"
        echo "        log: connect error"
        echo "}"
        echo

        # Prevent the SOCKS proxy from being used to pivot into local/private networks.
        # This blocks requests to loopback + RFC1918 destination ranges.
        if [ "${DANTE_BLOCK_PRIVATE_DESTS}" = "1" ]; then
            echo "socks block {"
            echo "        from: 0.0.0.0/0 to: 127.0.0.0/8"
            echo "        log: connect error"
            echo "}"
            echo
            echo "socks block {"
            echo "        from: 0.0.0.0/0 to: 10.0.0.0/8"
            echo "        log: connect error"
            echo "}"
            echo
            echo "socks block {"
            echo "        from: 0.0.0.0/0 to: 172.16.0.0/12"
            echo "        log: connect error"
            echo "}"
            echo
            echo "socks block {"
            echo "        from: 0.0.0.0/0 to: 192.168.0.0/16"
            echo "        log: connect error"
            echo "}"
            echo
        fi
        echo

        # SOCKS request allow-list (what those clients may do).

        # Allow localhost for in-container diagnostics/healthchecks.
        echo "socks pass {"
        echo "        from: 127.0.0.1/32 to: 0.0.0.0/0"
        echo "        protocol: tcp udp"
        echo "        log: ${DANTE_LOG}"
        if [ -n "${DANTE_SESSION_MAX}" ]; then
            echo "        session.max: ${DANTE_SESSION_MAX}"
        fi
        if [ -n "${DANTE_SESSION_THROTTLE}" ]; then
            echo "        session.throttle: ${DANTE_SESSION_THROTTLE}"
        fi
        echo "}"
        echo

        echo "socks pass {"
        echo "        from: 0.0.0.0/0 to: 127.0.0.1/32"
        echo "        command: bindreply udpreply"
        echo "        log: ${DANTE_LOG}"
        echo "}"
        echo

        for cidr in ${DANTE_ALLOW_FROM}; do
            echo "socks pass {"
            echo "        from: ${cidr} to: 0.0.0.0/0"
            echo "        protocol: tcp udp"
            echo "        log: ${DANTE_LOG}"
            if [ -n "${DANTE_SESSION_MAX}" ]; then
                echo "        session.max: ${DANTE_SESSION_MAX}"
            fi
            if [ -n "${DANTE_SESSION_THROTTLE}" ]; then
                echo "        session.throttle: ${DANTE_SESSION_THROTTLE}"
            fi
            echo "}"
            echo
            # Allow replies back to clients for BIND/UDP flows.
            echo "socks pass {"
            echo "        from: 0.0.0.0/0 to: ${cidr}"
            echo "        command: bindreply udpreply"
            echo "        log: ${DANTE_LOG}"
            echo "}"
            echo
        done
        echo "socks block {"
        echo "        from: 0.0.0.0/0 to: 0.0.0.0/0"
        echo "        log: connect error"
        echo "}"
    } > /etc/sockd.generated.conf
else
    # Still create a valid config file to avoid supervisord crash loops if enabled later.
    echo "logoutput: stderr" > /etc/sockd.generated.conf
fi

# Optional: raise process file-descriptor limit for high-connection workloads.
# (Affects all processes started by this entrypoint.)
ULIMIT_NOFILE_RAW="${ULIMIT_NOFILE:-}"
if [ -n "$ULIMIT_NOFILE_RAW" ]; then
    case "$ULIMIT_NOFILE_RAW" in
        ''|*[!0-9]*) : ;;
        *) ulimit -n "$ULIMIT_NOFILE_RAW" 2>/dev/null || true ;;
    esac
fi

# Squid typically drops privileges to user 'squid'; ensure it can write cache/logs.
if getent passwd squid >/dev/null 2>&1; then
    chown -R squid:squid /var/spool/squid /var/log/squid || true
fi
# Build cache dirs without daemonizing (avoid leaving a running squid instance)
squid -N -z || true
rm -f /var/run/squid.pid || true

# Start Supervisor to manage Squid and Flask
exec /usr/bin/supervisord -c /etc/supervisord.conf